<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - cameras</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      color: #808080;
      font-family:Monospace;
      font-size:13px;
      text-align:center;
      background-color: #000;
      margin: 0px;
      overflow: hidden;
    }
    #info {
      position: absolute;
      top: 0px; width: 100%;
      padding: 5px;
      z-index: 100;
    }
    a {
      color: #0080ff;
    }
    b { color: lightgreen }
  </style>
</head>
<body>


  <script src="<%= static_path(@conn, "/js/app.js") %>"></script>
  <script src="<%= static_path(@conn, "/js/three.min.js") %>"></script>
  <script src="<%= static_path(@conn, "/js/tween.min.js") %>"></script>
  <script src="<%= static_path(@conn, "/js/TrackballControls.js") %>"></script>
  <script src="<%= static_path(@conn, "/js/CSS3DRenderer.js") %>"></script>
  <script src="<%= static_path(@conn, "/js/dat.gui.min.js") %>"></script>

  <script src="<%= static_path(@conn, "/js/stats.min.js") %>"></script>

  <script>
    var SCREEN_WIDTH = window.innerWidth;
    var SCREEN_HEIGHT = window.innerHeight;
    var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
    var container, stats;
    var camera, scene, renderer, mesh;
    var cameraRig, activeCamera, activeHelper;
    var cameraPerspective, cameraOrtho;
    var cameraPerspectiveHelper, cameraOrthoHelper;
    var frustumSize = 600;
    init();
    animate();
    function init() {
      container = document.createElement( 'div' );
      document.body.appendChild( container );
      scene = new THREE.Scene();
      //
      camera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );
      camera.position.z = 2500;
      cameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );
      cameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );
      scene.add( cameraPerspectiveHelper );
      //
      cameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );
      cameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );
      scene.add( cameraOrthoHelper );
      //
      activeCamera = cameraPerspective;
      activeHelper = cameraPerspectiveHelper;
      // counteract different front orientation of cameras vs rig
      cameraOrtho.rotation.y = Math.PI;
      cameraPerspective.rotation.y = Math.PI;
      cameraRig = new THREE.Group();
      cameraRig.add( cameraPerspective );
      cameraRig.add( cameraOrtho );
      scene.add( cameraRig );
      //
      mesh = new THREE.Mesh(
        new THREE.SphereBufferGeometry( 100, 16, 8 ),
        new THREE.MeshBasicMaterial( { color: 0xff00ff, wireframe: true } )
      );
      scene.add( mesh );
      var mesh2 = new THREE.Mesh(
        new THREE.SphereBufferGeometry( 50, 16, 8 ),
        new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )
      );
      mesh2.position.y = 150;
      mesh.add( mesh2 );
      var mesh3 = new THREE.Mesh(
        new THREE.SphereBufferGeometry( 5, 16, 8 ),
        new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )
      );
      mesh3.position.z = 150;
      cameraRig.add( mesh3 );



      var margin=3;
      var cardWidth = 30;
      var cardHeight = 40;

      for(var i = 0; i < 100; i++){
        var card = new THREE.Mesh(
          new THREE.BoxBufferGeometry( cardWidth, cardHeight, 1 ),
          new THREE.MeshBasicMaterial( { color: 0x444*i, wireframe: false } )
        );
        card.position.z = 250;
        card.position.x = (Math.floor(i%10)*cardWidth) + margin*Math.floor(i%10) - 150;
        card.position.y = (Math.floor(i/10)*cardHeight) + margin*Math.floor(i/10) - 200;
        mesh3.add(card)
      }

      /*var card1 = new THREE.Mesh(
        new THREE.BoxBufferGeometry( 30, 40, 1 ),
        new THREE.MeshBasicMaterial( { color: 0xf0Af0f, wireframe: false } )
      );
      card1.position.z= 50;

      var card2 = new THREE.Mesh(
        new THREE.BoxBufferGeometry( 30, 40, 1 ),
        new THREE.MeshBasicMaterial( { color: 0xf0Af0f, wireframe: false } )
      );
      card2.position.z = 50;
      card2.position.x += card2.geometry.parameters.width + margin;

      var card3 = new THREE.Mesh(
        new THREE.BoxBufferGeometry( 30, 40, 1 ),
        new THREE.MeshBasicMaterial( { color: 0xf0Af0f, wireframe: false } )
      );
      card2.position.z = 50;
      card2.position.x += card2.geometry.parameters.width + margin;



      mesh3.add( card1 );
      mesh3.add( card2 );*/

      var light = new THREE.DirectionalLight( 0xffffff );
      light.position.set( 0, 2, 1 ).normalize();

      var mesh5 = new THREE.Mesh(
        new THREE.SphereBufferGeometry( 30, 30, 30 ),
        new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )
      );
      light.add(mesh5);
      scene.add(light);
      //
      var geometry = new THREE.BufferGeometry();
      var vertices = [];
      for ( var i = 0; i < 10000; i ++ ) {
        vertices.push(  THREE.Math.randFloatSpread( 2000 ) ); // x
        vertices.push(  THREE.Math.randFloatSpread( 2000 ) ); // y
        vertices.push(  THREE.Math.randFloatSpread( 2000 ) ); // z
      }
      geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
      var particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );
      scene.add( particles );
      //
      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
      container.appendChild( renderer.domElement );
      renderer.autoClear = false;
      //
      stats = new Stats();
      container.appendChild( stats.dom );
      //

      var params = {
				fov: 50,
        meshX: 0
			};

      var gui = new dat.GUI();
			gui.add( params, 'fov', 0, 90 ).step( 1 ).onChange( function( value ) {
        var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        cameraPerspective.fov = value;
			});

      /*
      gui.add( params, 'fov2', 0, 1 ).step( 0.01 ).onChange( function( value ) {
        var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        cameraPerspective.aspect = value * aspect;
			});*/
		    //gui.add( params, 'fov1' );
			  //gui.add( params, 'chordal' );
			gui.open();

      window.addEventListener( 'resize', onWindowResize, false );
      document.addEventListener( 'keydown', onKeyDown, false );
    }


    //
    function onKeyDown ( event ) {
      switch( event.keyCode ) {
        case 79: /*O*/
          activeCamera = cameraOrtho;
          activeHelper = cameraOrthoHelper;
          break;
        case 80: /*P*/
          activeCamera = cameraPerspective;
          activeHelper = cameraPerspectiveHelper;
          break;
      }
    }
    //
    function onWindowResize( event ) {
      SCREEN_WIDTH = window.innerWidth;
      SCREEN_HEIGHT = window.innerHeight;
      aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
      renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
      camera.aspect = 0.5 * aspect;
      camera.updateProjectionMatrix();

      cameraPerspective.aspect = 0.5 * aspect;
      cameraPerspective.updateProjectionMatrix();

      cameraOrtho.left   = - 0.5 * frustumSize * aspect / 2;
      cameraOrtho.right  =   0.5 * frustumSize * aspect / 2;
      cameraOrtho.top    =   frustumSize / 2;
      cameraOrtho.bottom = - frustumSize / 2;
      cameraOrtho.updateProjectionMatrix();
    }
    //
    function animate() {
      requestAnimationFrame( animate );
      render();
      stats.update();
    }
    function render() {
      var r = Date.now() * 0.0005;

      mesh.position.x = Math.abs(700 * Math.cos( r ));
      mesh.position.z = 700 * Math.sin( r );
      mesh.position.y = 700 * Math.sin( r );
      mesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );
      mesh.children[ 0 ].position.z = 70 * Math.sin( r );
      if ( activeCamera === cameraPerspective ) {
        //cameraPerspective.fov = 35 + 30 * Math.sin( 0.5 );
        cameraPerspective.far = mesh.position.length();
        cameraPerspective.updateProjectionMatrix();
        cameraPerspectiveHelper.update();
        cameraPerspectiveHelper.visible = true;
        cameraOrthoHelper.visible = false;
      } else {
        cameraOrtho.far = mesh.position.length();
        cameraOrtho.updateProjectionMatrix();
        cameraOrthoHelper.update();
        cameraOrthoHelper.visible = true;
        cameraPerspectiveHelper.visible = false;
      }
      cameraRig.lookAt( mesh.position );
      renderer.clear();
      activeHelper.visible = false;
      renderer.setViewport( 0, 0, SCREEN_WIDTH/2, SCREEN_HEIGHT );
      renderer.render( scene, activeCamera );
      activeHelper.visible = true;
      renderer.setViewport( SCREEN_WIDTH/2, 0, SCREEN_WIDTH/2, SCREEN_HEIGHT );
      renderer.render( scene, camera );
    }
  </script>

</body>
</html>
